<!DOCTYPE html>
<html>
<head>
  <title>Custom Nested Sortable List</title>
  <style>
    /* Basic styles for the list */

    ul {
      list-style-type: none;
      padding-left: 20px;
    }

    .task {
      margin: 5px 0;
      padding: 8px;
      background-color: #f9f9f9;
      border: 1px solid #ddd;
    }

    .task-header {
      display: flex;
      align-items: center;
      cursor: move; /* Make the header draggable */
    }

    .task-header strong {
      flex-grow: 1;
      cursor: pointer;
    }

    .add-subtask-button {
      margin-left: 10px;
      cursor: pointer;
    }

    .delete-task-button {
      margin-left: 5px;
      cursor: pointer;
    }

    .task:nth-child(even) {
      background-color: #f0f0f0;
    }

    .task:hover {
      background-color: #e0e0e0;
    }
  </style>
</head>
<body>

  <!-- Button to add a new main task -->
  <button id="add-main-task-button">Add Main Task</button>

  <!-- Main task list -->
  <ul id="main-list">
    <!-- Existing tasks -->
    <!-- For example, initial tasks can be added here if needed -->
  </ul>

  <!-- Add this inside the body -->
  <div id="task-input-modal" style="display:none;">
    <input type="text" id="task-input" placeholder="Task name">
    <button id="task-input-confirm">Add</button>
    <button id="task-input-cancel">Cancel</button>
  </div>

  <!-- Task template -->
  <template id="task-template">
    <li class="task">
      <div class="task-header">
        <strong>New Task</strong>
        <button class="add-subtask-button">Add Subtask</button>
        <button class="delete-task-button">Delete</button>
      </div>
      <ul></ul>
    </li>
  </template>

  <!-- Include Sortable.js from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

  <script>
    // Function to calculate nesting depth
    function getNestingDepth(el) {
      let depth = 0;
      while (el && el.id !== 'main-list') {
        if (el.tagName === 'UL') depth++;
        el = el.parentNode;
      }
      return depth;
    }

    // Function to initialize Sortable on a list
    function initializeSortable(list) {
      new Sortable(list, {
        group: 'nested',
        animation: 150,
        fallbackOnBody: true,
        swapThreshold: 0.65,
        handle: '.task-header',
        onEnd: function (evt) {
          const item = evt.item;
          const depth = getNestingDepth(item);

          if (depth > 3) {
            evt.from.insertBefore(item, evt.from.children[evt.oldIndex]);
            alert('You cannot nest tasks more than 3 levels deep.');
          }
          saveTasks();
        }
      });
    }

    // Initialize Sortable on the main list
    const mainList = document.getElementById('main-list');
    initializeSortable(mainList);

    // Initialize Sortable on existing nested lists (if any)
    const nestedLists = [].slice.call(document.querySelectorAll('#main-list ul'));
    nestedLists.forEach(function (list) {
      initializeSortable(list);
      list.classList.add('sortable-initialized');
    });

    // References
    const addMainTaskButton = document.getElementById('add-main-task-button');
    const taskTemplate = document.getElementById('task-template').content;

    // Function to create a task element
    function createTaskElement(taskName) {
      const newTask = document.importNode(taskTemplate, true);
      newTask.querySelector('strong').textContent = taskName;
      return newTask;
    }

    // Add Main Task event
    addMainTaskButton.addEventListener('click', function () {
      const taskName = prompt('Enter the name of the main task:');
      if (!taskName) return;

      const newTask = createTaskElement(taskName);
      mainList.appendChild(newTask);

      // Initialize Sortable on the new task's sublist
      const sublist = newTask.querySelector('ul');
      initializeSortable(sublist);
      sublist.classList.add('sortable-initialized');
      saveTasks();
    });

    // Handle Add Subtask button clicks using event delegation
    document.body.addEventListener('click', function (event) {
      if (event.target.classList.contains('add-subtask-button')) {
        const parentTask = event.target.closest('.task');
        const taskName = prompt('Enter the name of the subtask:');
        if (!taskName) return;

        const newSubtask = createTaskElement(taskName);

        const sublist = parentTask.querySelector('ul');
        sublist.appendChild(newSubtask);

        // Initialize Sortable on the sublist if not already initialized
        if (!sublist.classList.contains('sortable-initialized')) {
          initializeSortable(sublist);
          sublist.classList.add('sortable-initialized');
        }
        saveTasks();
      }
    });

    // Handle task name clicks for editing
    document.body.addEventListener('click', function (event) {
      if (event.target.tagName === 'STRONG') {
        const currentName = event.target.textContent;
        const newName = prompt('Edit task name:', currentName);
        if (newName) {
          event.target.textContent = newName;
          saveTasks();
        }
      }
    });

    // Handle Delete Task button clicks
    document.body.addEventListener('click', function (event) {
      if (event.target.classList.contains('delete-task-button')) {
        const taskItem = event.target.closest('.task');
        if (confirm('Are you sure you want to delete this task?')) {
          taskItem.parentNode.removeChild(taskItem);
          saveTasks();
        }
      }
    });

    // Saving and loading tasks
    function saveTasks() {
      const tasks = [];
      mainList.querySelectorAll('> .task').forEach(function (task) {
        tasks.push(serializeTask(task));
      });
      localStorage.setItem('taskList', JSON.stringify(tasks));
    }

    function serializeTask(task) {
      const taskData = {
        name: task.querySelector('strong').textContent,
        subtasks: []
      };
      const sublist = task.querySelector('ul');
      sublist.querySelectorAll('> .task').forEach(function (subtask) {
        taskData.subtasks.push(serializeTask(subtask));
      });
      return taskData;
    }

    function loadTasks() {
      const tasks = JSON.parse(localStorage.getItem('taskList'));
      if (tasks) {
        mainList.innerHTML = '';
        tasks.forEach(function (taskData) {
          const taskElement = createTaskFromData(taskData);
          mainList.appendChild(taskElement);
        });
      }
    }

    function createTaskFromData(taskData) {
      const taskElement = createTaskElement(taskData.name);
      const sublist = taskElement.querySelector('ul');
      taskData.subtasks.forEach(function (subtaskData) {
        const subtaskElement = createTaskFromData(subtaskData);
        sublist.appendChild(subtaskElement);
      });
      initializeSortable(sublist);
      sublist.classList.add('sortable-initialized');
      return taskElement;
    }

    // Load tasks on page load
    loadTasks();
  </script>

</body>
</html>
